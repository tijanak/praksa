<!DOCTYPE html>
<html>
  <head>
    <style>
      .toolbox {
        margin-bottom: 5px;
      }
      .image-container {
        position: relative;
        width: 1024px;
        height: 1024px;
      }
      .canvas-mask {
        position: absolute;
        top: 0;
        left: 0;
      }
      .image-map {
        position: absolute;
        top: 0;
        left: 0;
      }
    </style>
  </head>
  <body>
    <div id="imageContainer" class="image-container">
      <img id="imageMap" class="image-map" src="256x256_x4.png" />
      <canvas id="canvasMask" class="canvas-mask" />
    </div>
    <script>
      let modelScale = { height: 1024, width: 1024, samScale: 1 };
      let panelSize = { width: 40, height: 30 };

      let panels = [];

      const canvas = document.getElementById("canvasMask");
      const ctx = canvas.getContext("2d");
      canvas.width = modelScale.width;
      canvas.height = modelScale.height;
      function drawParallelThroughPoint(point) {
        ctx.fillStyle = "#0077CC66";
        ctx.strokeStyle = "#0077CC";
        ctx.beginPath();
        ctx.moveTo(0, point.y);
        ctx.lineTo(modelScale.width, point.y);
        ctx.stroke();
      }
      let testPoly = [
        {
          x: 598,
          y: 169,
        },
        {
          x: 664,
          y: 244,
        },
        {
          x: 754,
          y: 234,
        },
        {
          x: 662,
          y: 121,
        },
      ];
      let test2 = [
        {
          x: 206,
          y: 210,
        },
        {
          x: 226,
          y: 272,
        },
        {
          x: 319,
          y: 262,
        },
        {
          x: 234,
          y: 204,
        },
      ];
      let p2 = [
        { x: 0, y: 0 },
        { x: modelScale.width, y: 0 },
        { x: modelScale.width, y: modelScale.height },
        { x: 0, y: modelScale.height },
      ];
      let test3 = [
        {
          x: 702,
          y: 679,
        },
        {
          x: 641,
          y: 760,
        },
        {
          x: 639,
          y: 871,
        },
        {
          x: 753,
          y: 967,
        },
        {
          x: 846,
          y: 889,
        },
        {
          x: 876,
          y: 777,
        },
      ];
      drawPolygon(test3);
      function calculatePanels(roofVertexes, baseLine) {}
      function getMidPoint(polygon) {
        let midPoint = { x: 0, y: 0 };
        for (let i = 0; i < polygon.length; i++) {
          midPoint.x += polygon[i].x;
          midPoint.y += polygon[i].y;
        }
        midPoint.x /= polygon.length;
        midPoint.y /= polygon.length;
        return midPoint;
      }
      function radians(degrees) {
        return (degrees * Math.PI) / 180;
      }
      function rotatePolygon(polygon, degree) {
        degree = radians(degree);
        console.log(polygon);
        for (let i = 0; i < polygon.length; i++) {
          let vertexX = polygon[i].x,
            vertexY = polygon[i].y;
          polygon[i].x =
            vertexX * Math.cos(degree) - vertexY * Math.sin(degree);
          polygon[i].y =
            vertexX * Math.sin(degree) + vertexY * Math.cos(degree);
        }
        console.log(polygon);
      }
      function translatePolygon(polygon, x, y) {
        for (let i = 0; i < polygon.length; i++) {
          polygon[i].x += x;
          polygon[i].y += y;
        }
      }
      function getSlope(v1, v2) {
        return (Math.atan((v1.y - v2.y) / (v1.x - v2.x)) * 180) / Math.PI;
      }
      function findIntersection(v1, v2, y) {
        var m = (v1.y - v2.y) / (v1.x - v2.x);
        var c = v1.y - m * v1.x;
        var x = (y - c) / m;
        if (x > Math.max(v1.x, v2.x) || x < Math.min(v1.x, v2.x)) return null;
        return { x, y };
      }
      function drawDot(dot) {
        ctx.fillStyle = "#FF0000";
        var dotSize = 4;
        ctx.fillRect(
          dot.x - dotSize / 2,
          dot.y - dotSize / 2,
          dotSize,
          dotSize
        );
      }
      function drawHelperLine(v1, v2) {
        ctx.strokeStyle = "#CCCCCC";
        ctx.moveTo(v1.x, v1.y);
        ctx.lineTo(v2.x, v2.y);
        ctx.stroke();
      }
      function pairwise(verteces) {
        return verteces.map((v, i) => {
          if (i < verteces.length - 1) {
            return [v, verteces[i + 1]];
          } else return [v, verteces[0]];
        });
      }
      function drawPolygon(polygon) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        let midPoint = getMidPoint(polygon);
        let ind1 = 4,
          ind2 = 5;
        let point = { x: polygon[ind1].x, y: polygon[ind1].y };
        let point2 = { x: polygon[ind2].x, y: polygon[ind2].y };
        let deg = -getSlope(point2, point);
        console.log(deg);

        translatePolygon(polygon, -midPoint.x, -midPoint.y);
        rotatePolygon(polygon, deg);
        let rotate = false;
        for (let i = 0; i < polygon.length && !rotate; i++) {
          if (Math.round(polygon[i].y) > Math.round(polygon[ind1].y)) {
            rotate = true;

            console.log(polygon[i].y, polygon[ind1].y);
          }
        }
        if (rotate) {
          rotatePolygon(polygon, 180);
          deg += 180;
        }
        //rotatePolygon(polygon, -deg);
        translatePolygon(polygon, midPoint.x, midPoint.y);
        ctx.translate(midPoint.x, midPoint.y);
        ctx.rotate(-radians(deg));
        ctx.translate(-midPoint.x, -midPoint.y);

        ctx.fillStyle = "#0077CC66";
        ctx.strokeStyle = "#0077CC";
        let path = new Path2D();
        path.moveTo(polygon[0].x, polygon[0].y);
        for (let i = 1; i < polygon.length; i++) {
          path.lineTo(polygon[i].x, polygon[i].y);
        }
        path.lineTo(polygon[0].x, polygon[0].y);

        ctx.fill(path);
        ctx.stroke(path);
        panels.push(path);
        // console.log(pairwise(polygon));
        let lines = pairwise(polygon);
        let points = [];
        points.push(polygon[ind1]);
        points.push(polygon[ind2]);

        for (
          let h = (polygon[ind1].y -= panelSize.height);
          h >= 0;
          h -= panelSize.height
        ) {
          //drawParallelThroughPoint({ x: polygon[ind1].x, y: h });
          lines.forEach((v) => {
            let intersetion = findIntersection(v[0], v[1], h);
            //console.log(intersetion);
            if (intersetion) {
              let i = 0;
              while (i < points.length && points[i].y < intersetion.y) i++;
              if (i == points.length) point.push(intersetion);
              else points.splice(i, 0, intersetion);
            }
          });
        }
        for (let i = 0; i < points.length; i += 2) {
          if (i + 1 < points.length) {
            drawDot(points[i]);
            drawDot(points[i + 1]);
            drawHelperLine(points[i], points[i + 1]);
          }
        }
        ctx.fillStyle = "#FF77CC66";
        ctx.strokeStyle = "#FF77CC";
        canvas.addEventListener("click", (e) => {
          console.log(e.x, e.y);
          panels.forEach((panel, index) => {
            if (ctx.isPointInPath(panel, e.offsetX, e.offsetY)) {
              console.log("yuh", index);
            }
          });
        });
      }
    </script>
  </body>
</html>
