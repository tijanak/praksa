<!DOCTYPE html>
<html>
  <head>
    <style>
      .toolbox {
        margin-bottom: 5px;
      }
      .image-container {
        position: relative;
        width: 1024px;
        height: 1024px;
      }
      .canvas-mask {
        position: absolute;
        top: 0;
        left: 0;
      }
      .image-map {
        position: absolute;
        top: 0;
        left: 0;
      }
    </style>
  </head>
  <body>
    <div id="imageContainer" class="image-container">
      <img id="imageMap" class="image-map" src="256x256_x4.png" />
      <canvas id="canvasMask" class="canvas-mask" />
    </div>
    <script>
      let modelScale = { height: 1024, width: 1024, samScale: 1 };
      let panelSize = { width: 40, height: 30 };

      let panels = [];
      const canvas = document.getElementById("canvasMask");
      const ctx = canvas.getContext("2d");
      canvas.width = modelScale.width;
      canvas.height = modelScale.height;
      function drawParallelThroughPoint(point) {
        ctx.fillStyle = "#0077CC66";
        ctx.strokeStyle = "#0077CC";
        ctx.beginPath();
        ctx.moveTo(0, point.y);
        ctx.lineTo(modelScale.width, point.y);
        ctx.stroke();
      }
      let testPoly = [
        {
          x: 598,
          y: 169,
        },
        {
          x: 664,
          y: 244,
        },
        {
          x: 754,
          y: 234,
        },
        {
          x: 662,
          y: 121,
        },
      ];
      let test2 = [
        {
          x: 206,
          y: 210,
        },
        {
          x: 226,
          y: 272,
        },
        {
          x: 319,
          y: 262,
        },
        {
          x: 234,
          y: 204,
        },
      ];
      let p2 = [
        { x: 0, y: 0 },
        { x: modelScale.width, y: 0 },
        { x: modelScale.width, y: modelScale.height },
        { x: 0, y: modelScale.height },
      ];
      let test3 = [
        {
          x: 702,
          y: 679,
        },
        {
          x: 641,
          y: 760,
        },
        {
          x: 639,
          y: 871,
        },
        {
          x: 753,
          y: 967,
        },
        {
          x: 846,
          y: 889,
        },
        {
          x: 876,
          y: 777,
        },
      ];
      let random = [
        {
          x: 230,
          y: 241,
        },
        {
          x: 341,
          y: 205,
        },
        {
          x: 452,
          y: 280,
        },
        {
          //this
          x: 346,
          y: 292,
        },
        {
          x: 342,
          y: 363,
        },
        {
          x: 258,
          y: 321,
        },
      ];
      drawPolygon(random);
      function calculatePanels(roofVertexes, baseLine) {}
      function getMidPoint(polygon) {
        let midPoint = { x: 0, y: 0 };
        for (let i = 0; i < polygon.length; i++) {
          midPoint.x += polygon[i].x;
          midPoint.y += polygon[i].y;
        }
        midPoint.x /= polygon.length;
        midPoint.y /= polygon.length;
        return midPoint;
      }
      function radians(degrees) {
        return (degrees * Math.PI) / 180;
      }
      function rotatePolygon(polygon, degree) {
        degree = radians(degree);
        for (let i = 0; i < polygon.length; i++) {
          let vertexX = polygon[i].x,
            vertexY = polygon[i].y;
          polygon[i].x =
            vertexX * Math.cos(degree) - vertexY * Math.sin(degree);
          polygon[i].y =
            vertexX * Math.sin(degree) + vertexY * Math.cos(degree);
        }
      }
      function translatePolygon(polygon, x, y) {
        for (let i = 0; i < polygon.length; i++) {
          polygon[i].x += x;
          polygon[i].y += y;
        }
      }
      function getAngle(v1, v2) {
        return (Math.atan(getSlope(v1, v2)) * 180) / Math.PI;
      }
      function getSlope(v1, v2) {
        var kol = v1.x - v2.x;
        if (kol == null) return 0;
        return (v1.y - v2.y) / kol;
      }
      function findIntersectionWithParallelToX(v1, v2, y) {
        var kol = v1.x - v2.x;
        if (kol == null) return null;
        var m = (v1.y - v2.y) / kol;
        var c = v1.y - m * v1.x;
        if (m == 0) return null;
        var x = (y - c) / m;
        if (x > Math.max(v1.x, v2.x) || x < Math.min(v1.x, v2.x)) return null;
        return { x, y };
      }
      function drawDot(dot) {
        ctx.fillStyle = "#FF0000";
        var dotSize = 4;
        ctx.fillRect(
          dot.x - dotSize / 2,
          dot.y - dotSize / 2,
          dotSize,
          dotSize
        );
      }
      function drawHelperLine(v1, v2) {
        ctx.strokeStyle = "#CCCCCC";
        ctx.moveTo(v1.x, v1.y);
        ctx.lineTo(v2.x, v2.y);
        ctx.stroke();
      }
      function pairwise(verteces) {
        return verteces.map((v, i) => {
          if (i < verteces.length - 1) {
            return [v, verteces[i + 1]];
          } else return [v, verteces[0]];
        });
      }
      function findIntersectionsAtY(edges, y) {
        let points = [];
        edges.forEach((v) => {
          let intersetion = findIntersectionWithParallelToX(v[0], v[1], y);
          if (intersetion) {
            points.push(intersetion);
          } else {
          }
        });
        points.sort((a, b) => a.x - b.x);
        return points;
      }

      function iterateThroughtList(start, cbFunc) {
        let node = start;
        while (node != null) {
          cbFunc(node);
          node = node.next;
        }
      }
      function adjustX(node) {
        iterateThroughtList(node, (n) => (n.xTek += n.slope));
      }
      function filterList(start, cond) {
        let prev = null;
        let node = start;
        while (node != null) {
          if (cond(node)) {
            if (prev == null) {
              start = node.next;
            } else {
              prev.next = node.next;
            }
          }
          prev = node;
          node = node.next;
        }
        return start;
      }
      function addToList(aet, edge) {
        if (aet == null) return edge;
        current = aet;
        prev = null;
        while (current != null && current.xTek < edge.xTek) {
          prev = current;

          current = current.next;
        }
        edge.next = current;
        if (prev == null) aet = edge;
        else prev.next = edge;
        return aet;
      }
      function addNewEdges(aet, newEdges) {
        let newList = aet;
        iterateThroughtList(newEdges, (node) => {
          newList = addToList(aet, node);
        });
        return aet;
      }
      function makeEdgeTable(polyon) {
        let edgeTable = new Map();
        let lines = pairwise(polyon);
        lines.forEach((line) => {
          let max = line[0],
            min = line[1];
          if (line[0].y < line[1].y) {
            max = line[1];
            min = line[0];
          }
          let slope = getSlope(line[0], line[1]);
          if (slope != 0) {
            slope = 1 / slope;
          }
          let edge = {
            ymax: max.y,
            xTek: min.x,
            slope: slope,
            next: null,
          };
          let secondEdge = null;
          if (slope == 0) {
            secondEdge = {
              ymax: max.y,
              xTek: max.x,
              slope: slope,
              next: null,
            };
          }
          if (edgeTable.has(Math.round(min.y))) {
            let edges = edgeTable.get(Math.round(min.y));
            let newList = addToList(edges, edge);
            if (secondEdge != null) newList = addToList(newList, secondEdge);
            edgeTable.set(Math.round(min.y), newList);
          } else {
            edge.next = secondEdge;
            edgeTable.set(Math.round(min.y), edge);
          }
        });
        return edgeTable;
      }
      function getIntersectionsV2(polygon, baseLineY, lineDistance) {
        let minMaxY = getMinMaxY(polygon);
        let polygonMaxY = minMaxY.maxY;
        let polygonMinY = minMaxY.minY;

        let edgeTable = makeEdgeTable(polygon);
        let intersections = [];
        let aet = null;
        let deltaY = Math.floor((baseLineY - polygonMinY) / lineDistance);
        let startY = Math.round(baseLineY - deltaY * lineDistance);
        console.log(edgeTable);
        for (let y = Math.round(polygonMinY); y < Math.round(startY); y++) {
          if (edgeTable.has(y)) {
            let newEdges = edgeTable.get(y);
            aet = addToList(aet, newEdges);
          }
          adjustX(aet);
        }
        for (let y = Math.round(startY); y <= Math.round(polygonMaxY); y++) {
          aet = filterList(aet, (node) => node.ymax <= y);
          adjustX(aet);
          if (edgeTable.has(y)) {
            let newEdges = edgeTable.get(y);
            iterateThroughtList(newEdges, (edge) => {
              aet = addToList(aet, {
                ymax: edge.ymax,
                xTek: edge.xTek,
                slope: edge.slope,
                next: null,
              });
            });
          }
          if (Number.isInteger((y - startY) / lineDistance)) {
            let points = [];
            iterateThroughtList(aet, (node) =>
              points.push({ x: node.xTek, y })
            );
            intersections.push(points);
          }
        }
        return intersections;
      }
      function getIntersections(polygon, baseLineY, lineDistance) {
        let minMaxY = getMinMaxY(polygon);
        let polygonMaxY = minMaxY.maxY;
        let polygonMinY = minMaxY.minY;
        let polygonLines = pairwise(polygon);
        let intersections = [];
        for (let h = baseLineY; h >= polygonMinY; h -= lineDistance) {
          intersections.push(findIntersectionsAtY(polygonLines, h));
        }
        intersections = intersections.reverse();
        for (
          let h = baseLineY + lineDistance;
          h <= polygonMaxY;
          h += lineDistance
        ) {
          intersections.push(findIntersectionsAtY(polygonLines, h));
        }
        return intersections;
      }
      function getMinMaxY(polygon) {
        let ys = polygon.map((v) => v.y);
        let maxY = Math.max(...ys);
        let minY = Math.min(...ys);
        return { maxY, minY };
      }
      function isDotInRectangle(upperLeftCorner, lowerRighCorner, dot) {
        return (
          dot.x > upperLeftCorner.x &&
          dot.x < lowerRighCorner.x &&
          dot.y < lowerRighCorner.y &&
          dot.y > upperLeftCorner.y
        );
      }
      function drawPolygon(polygon) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        let midPoint = getMidPoint(polygon);
        let ind1 = 0,
          ind2 = 5;
        let point = { x: polygon[ind1].x, y: polygon[ind1].y };
        let point2 = { x: polygon[ind2].x, y: polygon[ind2].y };
        let deg = -getAngle(point2, point);

        translatePolygon(polygon, -midPoint.x, -midPoint.y);
        rotatePolygon(polygon, deg);

        translatePolygon(polygon, midPoint.x, midPoint.y);
        //ctx.translate(midPoint.x, midPoint.y);
        //ctx.rotate(-radians(deg));
        //ctx.translate(-midPoint.x, -midPoint.y);
        // ctx.translate(0, -deltaY);

        ctx.fillStyle = "#0077CC66";
        ctx.strokeStyle = "#0077CC";
        let path = new Path2D();
        path.moveTo(polygon[0].x, polygon[0].y);
        for (let i = 1; i < polygon.length; i++) {
          path.lineTo(polygon[i].x, polygon[i].y);
        }
        path.lineTo(polygon[0].x, polygon[0].y);

        ctx.fill(path);
        ctx.stroke(path);
        panels.push(path);
        let lines = pairwise(polygon);
        let intersections = getIntersectionsV2(
          polygon,
          polygon[ind1].y,
          panelSize.height
        );
        console.log(intersections);
        for (let i = 0; i < intersections.length; i++) {
          for (let j = 0; j < intersections[i].length - 1; j++) {
            drawDot(intersections[i][j]);
            drawDot(intersections[i][j + 1]);
            drawHelperLine(intersections[i][j], intersections[i][j + 1]);
          }
        }
        ctx.fillStyle = "#FF77CC66";
        ctx.strokeStyle = "#FF77CC";
        canvas.addEventListener("click", (e) => {
          console.log(e.offsetX, e.offsetY);
          panels.forEach((panel, index) => {
            if (ctx.isPointInPath(panel, e.offsetX, e.offsetY)) {
              console.log("kliknut", index);
            }
          });
        });
      }
    </script>
  </body>
</html>
