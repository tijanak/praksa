<!DOCTYPE html>
<html>
  <head>
    <style>
      .toolbox {
        margin-bottom: 5px;
      }
      .image-container {
        position: relative;
        width: 1024px;
        height: 1024px;
      }
      .canvas-mask {
        position: absolute;
        top: 0;
        left: 0;
      }
      .image-map {
        position: absolute;
        top: 0;
        left: 0;
      }
    </style>
  </head>
  <body>
    <div id="imageContainer" class="image-container">
      <img id="imageMap" class="image-map" src="256x256_x4.png" />
      <canvas id="canvasMask" class="canvas-mask" />
    </div>
    <script>
      let modelScale = { height: 1024, width: 1024, samScale: 1 };
      let panelSize = { width: 20, height: 50 };

      let parallellsKey = "slope0";
      let panels = [];
      const canvas = document.getElementById("canvasMask");
      const ctx = canvas.getContext("2d");
      canvas.width = modelScale.width;
      canvas.height = modelScale.height;
      //TODO - obrisati ako ne treba
      function drawParallelThroughPoint(point) {
        ctx.fillStyle = "#0077CC66";
        ctx.strokeStyle = "#0077CC";
        ctx.beginPath();
        ctx.moveTo(0, point.y);
        ctx.lineTo(modelScale.width, point.y);
        ctx.stroke();
      }
      let testPoly = [
        {
          x: 598,
          y: 169,
        },
        {
          x: 664,
          y: 244,
        },
        {
          x: 754,
          y: 234,
        },
        {
          x: 662,
          y: 121,
        },
      ];
      let test2 = [
        {
          x: 206,
          y: 210,
        },
        {
          x: 226,
          y: 272,
        },
        {
          x: 319,
          y: 262,
        },
        {
          x: 234,
          y: 204,
        },
      ];
      let test3 = [
        {
          x: 702,
          y: 679,
        },
        {
          x: 641,
          y: 760,
        },
        {
          x: 639,
          y: 871,
        },
        {
          x: 753,
          y: 967,
        },
        {
          x: 846,
          y: 889,
        },
        {
          x: 876,
          y: 777,
        },
      ];
      let random = [
        {
          x: 230,
          y: 241,
        },
        {
          x: 341,
          y: 205,
        },
        {
          x: 452,
          y: 280,
        },
        {
          //this
          x: 346,
          y: 292,
        },
        {
          x: 342,
          y: 363,
        },
        {
          x: 258,
          y: 321,
        },
      ];
      function getMidPoint(polygon) {
        let midPoint = { x: 0, y: 0 };
        for (let i = 0; i < polygon.length; i++) {
          midPoint.x += polygon[i].x;
          midPoint.y += polygon[i].y;
        }
        midPoint.x /= polygon.length;
        midPoint.y /= polygon.length;
        return midPoint;
      }
      function radians(degrees) {
        return (degrees * Math.PI) / 180;
      }
      function rotatePolygon(polygon, degree) {
        degree = radians(degree);
        for (let i = 0; i < polygon.length; i++) {
          let vertexX = polygon[i].x,
            vertexY = polygon[i].y;
          polygon[i].x =
            vertexX * Math.cos(degree) - vertexY * Math.sin(degree);
          polygon[i].y =
            vertexX * Math.sin(degree) + vertexY * Math.cos(degree);
        }
      }
      function translatePolygon(polygon, x, y) {
        for (let i = 0; i < polygon.length; i++) {
          polygon[i].x += x;
          polygon[i].y += y;
        }
      }
      function getAngle(v1, v2) {
        return (Math.atan(getSlope(v1, v2)) * 180) / Math.PI;
      }
      function getSlope(v1, v2) {
        var kol = v1.x - v2.x;
        if (kol == null) return 0;
        return (v1.y - v2.y) / kol;
      }
      function drawDot(dot) {
        ctx.fillStyle = "#FF0000";
        var dotSize = 4;
        ctx.fillRect(
          dot.x - dotSize / 2,
          dot.y - dotSize / 2,
          dotSize,
          dotSize
        );
      }

      function drawHelperLine(v1, v2) {
        ctx.strokeStyle = "#CCCCCC";
        ctx.moveTo(v1.x, v1.y);
        ctx.lineTo(v2.x, v2.y);
        ctx.stroke();
      }
      //vraca parove tacaka koje cine liniju
      function getLines(verteces) {
        return verteces.map((v, i) => {
          if (i < verteces.length - 1) {
            return [v, verteces[i + 1]];
          } else return [v, verteces[0]];
        });
      }
      //obrada lancane liste
      function iterateThroughtList(start, cbFunc) {
        let node = start;
        while (node != null) {
          cbFunc(node);
          node = node.next;
        }
      }
      //promena tekucih vrednosti x linija na osnovu njihovih nagiba
      function adjustX(node) {
        iterateThroughtList(node, (n) => (n.xTek += n.slope));
      }
      //izbacivanje elemenata koji zadovoljavaju uslov iz lancane liste
      function filterList(start, cond) {
        let prev = null;
        let node = start;
        while (node != null) {
          if (cond(node)) {
            if (prev == null) {
              start = node.next;
            } else {
              prev.next = node.next;
            }
          } else prev = node;
          node = node.next;
        }
        return start;
      }
      //dodavanje linije u lancanu listu
      function addToList(start, edge) {
        if (start == null) return edge;
        current = start;
        prev = null;
        while (current != null && current.xTek < edge.xTek) {
          prev = current;

          current = current.next;
        }
        edge.next = current;
        if (prev == null) start = edge;
        else prev.next = edge;
        return start;
      }
      //kreira edge table za scan line algoritam
      function makeEdgeTable(polyon) {
        let edgeTable = new Map();
        let lines = getLines(polyon);
        edgeTable.set(parallellsKey, []);
        lines.forEach((line, i) => {
          let max = line[0],
            min = line[1];
          if (line[0].y < line[1].y) {
            max = line[1];
            min = line[0];
          }
          let slope = getSlope(line[0], line[1]);
          if (slope != 0) {
            slope = 1 / slope;

            let edge = {
              id: i,
              ymax: max.y,
              xTek: min.x,
              slope: slope,
              next: null,
            };
            if (edgeTable.has(Math.round(min.y))) {
              let edges = edgeTable.get(Math.round(min.y));
              let newList = addToList(edges, edge);
              edgeTable.set(Math.round(min.y), newList);
            } else {
              edgeTable.set(Math.round(min.y), edge);
            }
          } else {
            //linije paralelne sa x ne ukljucujemo u scan line
            //ali za neke slucajeve je potrebno
            //dodati naknadno temena paralelne linije pa ih prenosimo
            edgeTable.get(parallellsKey).push(line);
          }
        });
        return edgeTable;
      }
      function getIntersections(polygon, baseLineY, lineDistance) {
        let minMaxY = getMinMaxY(polygon);
        let polygonMaxY = minMaxY.maxY;
        let polygonMinY = minMaxY.minY;

        let edgeTable = makeEdgeTable(polygon);
        let intersections = new Map();
        let aet = null;
        let deltaY = Math.floor((baseLineY - polygonMinY) / lineDistance);
        let startY = Math.round(baseLineY - deltaY * lineDistance);
        for (let y = Math.round(polygonMinY); y < Math.round(startY); y++) {
          if (edgeTable.has(y)) {
            let newEdges = edgeTable.get(y);
            aet = addToList(aet, newEdges);
          }

          adjustX(aet);
        }
        for (let y = Math.round(startY); y <= Math.round(polygonMaxY); y++) {
          if (edgeTable.has(y)) {
            let newEdges = edgeTable.get(y);
            iterateThroughtList(newEdges, (edge) => {
              aet = addToList(aet, {
                id: edge.id,
                ymax: edge.ymax,
                xTek: edge.xTek,
                slope: edge.slope,
                next: null,
              });
            });
          }
          aet = filterList(aet, (node) => {
            return node.ymax <= y;
          });
          if (Number.isInteger((y - startY) / lineDistance)) {
            let points = [];
            iterateThroughtList(aet, (node) => {
              points.push(Math.round(node.xTek));
            });
            intersections.set(y, points);
          }

          adjustX(aet);
        }
        let parallels = edgeTable.get(parallellsKey);
        parallels.forEach((line) => {
          if (intersections.has(Math.round(line[0].y))) {
            let vertexes = intersections.get(Math.round(line[0].y));
            let containsFirstVertex =
              vertexes
                .map((v) => Math.round(v))
                .find((v) => v == Math.round(line[0].x)) != undefined;
            let containsSecondVertex =
              vertexes
                .map((v) => Math.round(v))
                .find((v) => v == Math.round(line[1].x)) != undefined;

            if (!(containsFirstVertex && containsSecondVertex)) {
              vertexes.push(line[0].x);
              vertexes.push(line[1].x);
            }
          }
        });
        intersections.forEach((xValues) => {
          xValues.sort();
        });
        return intersections;
      }
      function getMinMaxY(polygon) {
        let ys = polygon.map((v) => v.y);
        let maxY = Math.max(...ys);
        let minY = Math.min(...ys);
        return { maxY, minY };
      }
      function rotateCanvas(ctx, deg, rotationCenter) {
        ctx.translate(rotationCenter.x, rotationCenter.y);
        ctx.rotate(-radians(deg));
        ctx.translate(-rotationCenter.x, -rotationCenter.y);
      }
      //TODO - obrisati ako ne treba
      function isDotInRectangle(upperLeftCorner, lowerRighCorner, dot) {
        return (
          dot.x > upperLeftCorner.x &&
          dot.x < lowerRighCorner.x &&
          dot.y < lowerRighCorner.y &&
          dot.y > upperLeftCorner.y
        );
      }
      function drawScanLines(intersections) {
        intersections.forEach((xValues, y) => {
          if (xValues.length % 2 != 0) console.log("greska");
          for (let j = 0; j < xValues.length - 1; j += 2) {
            if (j + 1 < xValues.length) {
              drawDot({ x: xValues[j], y: y });
              drawDot({ x: xValues[j + 1], y: y });
              drawHelperLine(
                { x: xValues[j], y: y },
                { x: xValues[j + 1], y: y }
              );
            }
          }
        });
      }
      //rotira poligon za deg stepeni oko date tacke
      function rotatePolygonAroundPoint(polygon, deg, point) {
        translatePolygon(polygon, -point.x, -point.y);
        rotatePolygon(polygon, deg);
        translatePolygon(polygon, point.x, point.y);
      }
      //rotiranje krova oko njegove centralne tacke
      function rotateRoof(ctx, roofPolygon, deg) {
        let midPoint = getMidPoint(roofPolygon);
        rotatePolygonAroundPoint(roofPolygon, deg, midPoint);
      }
      //vraca kljuceve iz mape kao sortirani niz
      function sortedNumberKeys(map) {
        return [...map.keys()].sort((a, b) => a - b);
      }
      function combineIntersectionPairs(xValues) {
        return xValues.reduce(
          (accumulator, currentValue, currentIndex, array) => {
            if (currentIndex % 2 === 0) {
              accumulator.push(array.slice(currentIndex, currentIndex + 2));
            }
            return accumulator;
          },
          []
        );
      }
      function getXBounds(lowerPointsX, upperPointsX) {
        return {
          leftBound: Math.max(lowerPointsX[0], upperPointsX[0]),
          rightBound: Math.min(lowerPointsX[1], upperPointsX[1]),
        };
      }
      function getPlacementAreaBounds(lowerXValues, upperxValues) {
        let lowerPairs = combineIntersectionPairs(lowerXValues);
        let upperPairs = combineIntersectionPairs(upperxValues);
        let placementAreaBounds = [];
        let lowerInd = 0,
          upperInd = 0;
        while (lowerInd < lowerPairs.length && upperInd < upperPairs.length) {
          let xBounds = getXBounds(lowerPairs[lowerInd], upperPairs[upperInd]);
          if (xBounds.rightBound >= lowerPairs[lowerInd][1]) {
            lowerInd++;
          }
          if (xBounds.rightBound >= upperPairs[upperInd][1]) {
            upperInd++;
          }
          placementAreaBounds.push(xBounds);
        }
        return placementAreaBounds;
      }
      function getPlacementAreas(intersections) {
        let placementAreas = [];
        let sortedKeys = sortedNumberKeys(intersections);
        for (let i = 0; i < sortedKeys.length - 1; i++) {
          let xBounds = getPlacementAreaBounds(
            intersections.get(sortedKeys[i]),
            intersections.get(sortedKeys[i + 1])
          );
          xBounds.forEach((bounds) => {
            placementAreas.push({
              lowerY: sortedKeys[i],
              upperY: sortedKeys[i + 1],
              rightBound: bounds.rightBound,
              leftBound: bounds.leftBound,
            });
          });
        }
        return placementAreas;
      }
      function getPanelsInPlacementArea(placementArea, panelSizeX) {
        let panels = [];
        for (
          let x = placementArea.leftBound;
          x + panelSizeX <= placementArea.rightBound;
          x += panelSizeX
        ) {
          panels.push({
            x: x + panelSizeX / 2,
            y: (placementArea.upperY + placementArea.lowerY) / 2,
          });
        }
        return panels;
      }
      function getPanels(roofPolygon, baseLineFirstIndex, w, h) {
        let calculatedPanels = [];

        let lines = getLines(roofPolygon);
        roofPolygon.forEach((v) => {
          v.x = Math.round(v.x);
          v.y = Math.round(v.y);
        });
        let intersections = getIntersections(
          roofPolygon,
          roofPolygon[baseLineFirstIndex].y,
          h
        );
        // drawScanLines(intersections);
        let placementAreas = getPlacementAreas(intersections);
        placementAreas.forEach((area) => {
          let newPanels = getPanelsInPlacementArea(area, w);

          calculatedPanels.push(...newPanels);
        });
        return calculatedPanels;
      }

      function calculatePanels(ctx, roofPolygon, baseLineFirstIndex, w, h) {
        let point = {
          x: roofPolygon[baseLineFirstIndex].x,
          y: roofPolygon[baseLineFirstIndex].y,
        };
        let point2 = {
          x: roofPolygon[baseLineFirstIndex + 1].x,
          y: roofPolygon[baseLineFirstIndex + 1].y,
        };
        let deg = -getAngle(point2, point);

        rotateRoof(ctx, roofPolygon, deg);
        let uprightPanels = getPanels(roofPolygon, baseLineFirstIndex, w, h);
        let sidewaysPanels = getPanels(roofPolygon, baseLineFirstIndex, h, w);
        if (uprightPanels.length > sidewaysPanels.length) {
          return {
            rotation: 0,
            panels: uprightPanels.map((panel) => {
              return { midPoint: panel, selected: true };
            }),
          };
        }
        return {
          rotation: 90,
          panels: sidewaysPanels.map((panel) => {
            return { midPoint: panel, selected: true };
          }),
        };
      }
      function getRectangle(midPoint, w, h) {
        return [
          { x: midPoint.x - w / 2, y: midPoint.y - h / 2 },
          { x: midPoint.x + w / 2, y: midPoint.y - h / 2 },
          { x: midPoint.x + w / 2, y: midPoint.y + h / 2 },
          { x: midPoint.x - w / 2, y: midPoint.y + h / 2 },
        ];
      }
      function drawPolygon(ctx, polygon, fill, stroke) {
        ctx.fillStyle = fill;
        ctx.strokeStyle = stroke;
        ctx.moveTo(polygon[0].x, polygon[0].y);
        for (let i = 1; i < polygon.length; i++) {
          ctx.lineTo(polygon[i].x, polygon[i].y);
        }
        ctx.lineTo(polygon[0].x, polygon[0].y);
        ctx.fill();
        ctx.stroke();
      }
      testing(random);
      function testing(polygon) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        let roofPanels = calculatePanels(
          ctx,
          polygon,
          0,
          panelSize.width,
          panelSize.height
        );
        ctx.fillStyle = "#0077CC66";
        ctx.strokeStyle = "#0077CC";
        let path = new Path2D();
        path.moveTo(polygon[0].x, polygon[0].y);
        for (let i = 1; i < polygon.length; i++) {
          path.lineTo(polygon[i].x, polygon[i].y);
        }
        path.lineTo(polygon[0].x, polygon[0].y);

        ctx.fill(path);
        ctx.stroke(path);
        panels.push(path);
        roofPanels.panels.forEach((panel) => {
          let rect = getRectangle(
            panel.midPoint,
            panelSize.width,
            panelSize.height
          );
          rotatePolygonAroundPoint(rect, roofPanels.rotation, panel.midPoint);
          drawPolygon(ctx, rect, "#00FF00", "CCCCCC");
        });
        ctx.fillStyle = "#FF77CC66";
        ctx.strokeStyle = "#FF77CC";
        canvas.addEventListener("click", (e) => {
          console.log(e.offsetX, e.offsetY);
          panels.forEach((panel, index) => {
            if (ctx.isPointInPath(panel, e.offsetX, e.offsetY)) {
              console.log("kliknut", index);
            }
          });
        });
      }
    </script>
  </body>
</html>
