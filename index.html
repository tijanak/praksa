<!DOCTYPE html>
<html>
  <head>
    <style>
      .toolbox {
        margin-bottom: 5px;
      }
      .image-container {
        position: relative;
        width: 1024px;
        height: 1024px;
      }
      .canvas-mask {
        position: absolute;
        top: 0;
        left: 0;
      }
      .image-map {
        position: absolute;
        top: 0;
        left: 0;
      }
    </style>
  </head>
  <body>
    <div id="imageContainer" class="image-container">
      <img id="imageMap" class="image-map" src="256x256_x4.png" />
      <canvas id="canvasMask" class="canvas-mask" />
    </div>
    <script>
      let modelScale = { height: 1024, width: 1024, samScale: 1 };
      let panelSize = { width: 40, height: 30 };

      let panels = [];
      const canvas = document.getElementById("canvasMask");
      const ctx = canvas.getContext("2d");
      canvas.width = modelScale.width;
      canvas.height = modelScale.height;
      function drawParallelThroughPoint(point) {
        ctx.fillStyle = "#0077CC66";
        ctx.strokeStyle = "#0077CC";
        ctx.beginPath();
        ctx.moveTo(0, point.y);
        ctx.lineTo(modelScale.width, point.y);
        ctx.stroke();
      }
      let testPoly = [
        {
          x: 598,
          y: 169,
        },
        {
          x: 664,
          y: 244,
        },
        {
          x: 754,
          y: 234,
        },
        {
          x: 662,
          y: 121,
        },
      ];
      let test2 = [
        {
          x: 206,
          y: 210,
        },
        {
          x: 226,
          y: 272,
        },
        {
          x: 319,
          y: 262,
        },
        {
          x: 234,
          y: 204,
        },
      ];
      let p2 = [
        { x: 0, y: 0 },
        { x: modelScale.width, y: 0 },
        { x: modelScale.width, y: modelScale.height },
        { x: 0, y: modelScale.height },
      ];
      let test3 = [
        {
          x: 702,
          y: 679,
        },
        {
          x: 641,
          y: 760,
        },
        {
          x: 639,
          y: 871,
        },
        {
          x: 753,
          y: 967,
        },
        {
          x: 846,
          y: 889,
        },
        {
          x: 876,
          y: 777,
        },
      ];
      let random = [
        {
          x: 230,
          y: 241,
        },
        {
          x: 341,
          y: 205,
        },
        {
          x: 452,
          y: 280,
        },
        {
          //this
          x: 346,
          y: 292,
        },
        {
          x: 342,
          y: 363,
        },
        {
          x: 258,
          y: 321,
        },
      ];
      drawPolygon(random);
      function calculatePanels(roofVertexes, baseLine) {}
      function getMidPoint(polygon) {
        let midPoint = { x: 0, y: 0 };
        for (let i = 0; i < polygon.length; i++) {
          midPoint.x += polygon[i].x;
          midPoint.y += polygon[i].y;
        }
        midPoint.x /= polygon.length;
        midPoint.y /= polygon.length;
        return midPoint;
      }
      function radians(degrees) {
        return (degrees * Math.PI) / 180;
      }
      function rotatePolygon(polygon, degree) {
        degree = radians(degree);
        for (let i = 0; i < polygon.length; i++) {
          let vertexX = polygon[i].x,
            vertexY = polygon[i].y;
          polygon[i].x =
            vertexX * Math.cos(degree) - vertexY * Math.sin(degree);
          polygon[i].y =
            vertexX * Math.sin(degree) + vertexY * Math.cos(degree);
        }
      }
      function translatePolygon(polygon, x, y) {
        for (let i = 0; i < polygon.length; i++) {
          polygon[i].x += x;
          polygon[i].y += y;
        }
      }
      function getAngle(v1, v2) {
        return (Math.atan(getSlope(v1, v2)) * 180) / Math.PI;
      }
      function getSlope(v1, v2) {
        var kol = v1.x - v2.x;
        if (kol == null) return 0;
        return (v1.y - v2.y) / kol;
      }
      function findIntersectionWithParallelToX(v1, v2, y) {
        var kol = v1.x - v2.x;
        if (kol == null) return null;
        var m = (v1.y - v2.y) / kol;
        var c = v1.y - m * v1.x;
        if (m == 0) return null;
        var x = (y - c) / m;
        if (x > Math.max(v1.x, v2.x) || x < Math.min(v1.x, v2.x)) return null;
        return { x, y };
      }
      function drawDot(dot) {
        ctx.fillStyle = "#FF0000";
        var dotSize = 4;
        ctx.fillRect(
          dot.x - dotSize / 2,
          dot.y - dotSize / 2,
          dotSize,
          dotSize
        );
      }
      function drawHelperLine(v1, v2) {
        ctx.strokeStyle = "#CCCCCC";
        ctx.moveTo(v1.x, v1.y);
        ctx.lineTo(v2.x, v2.y);
        ctx.stroke();
      }
      function pairwise(verteces) {
        return verteces.map((v, i) => {
          if (i < verteces.length - 1) {
            return [v, verteces[i + 1]];
          } else return [v, verteces[0]];
        });
      }
      function findIntersectionsAtY(edges, y) {
        let points = [];
        edges.forEach((v) => {
          let intersetion = findIntersectionWithParallelToX(v[0], v[1], y);
          if (intersetion) {
            points.push(intersetion);
          } else {
          }
        });
        points.sort((a, b) => a.x - b.x);
        return points;
      }
      function makeEdgeTable(polyon) {
        let edgeTable = new Map();
        let lines = pairwise(polyon);
        lines.forEach((line) => {
          let max = line[0],
            min = line[1],
            maxX = line[0].x,
            minX = line[1].x;
          if (line[0].y < line[1].y) {
            max = line[1];
            min = line[0];
          }
          if (maxX < minX) {
            maxX = line[1].x;
            minX = line[0].x;
          }
          let slope = getSlope(line[0], line[1]);
          let edge = {
            ymax: max.y,
            ymin: min.y,
            xmax: maxX,
            xmin: minX,
            xTek: minX,
            slope: 1 / slope,
            next: null,
          };
          if (edgeTable.has(Math.round(min.y))) {
            let currentEdge = edgeTable.get(Math.round(min.y));
            let previous = null;
            while (currentEdge != null && currentEdge.xTek < edge.xTek) {
              previous = currentEdge;
              currentEdge = currentEdge.next;
            }
            edge.next = currentEdge;
            if (previous != null) {
              previous.next = edge;
            } else {
              edgeTable.set(Math.round(min.y), edge);
            }
          } else {
            edgeTable.set(Math.round(min.y), edge);
          }

          if (max.y != min.y) {
            let newEdge = Object.assign({}, edge);
            newEdge.next = null;
            if (edgeTable.has(Math.round(max.y))) {
              let currentEdge = edgeTable.get(Math.round(max.y));
              let previous = null;
              while (currentEdge != null && currentEdge.xTek < newEdge.xTek) {
                previous = currentEdge;
                currentEdge = currentEdge.next;
              }
              newEdge.next = currentEdge;
              if (previous != null) {
                previous.next = newEdge;
              } else {
                edgeTable.set(Math.round(max.y), newEdge);
              }
            } else {
              edgeTable.set(Math.round(max.y), newEdge);
            }
          }
        });
        return edgeTable;
      }
      function getIntersectionsV2(polygon, baseLineY, lineDistance) {
        let minMaxY = getMinMaxY(polygon);
        let polygonMaxY = minMaxY.maxY;
        let polygonMinY = minMaxY.minY;

        let edgeTable = makeEdgeTable(polygon);
        console.log(edgeTable);
        let intersections = [];
        let aet = null;
        for (let h = baseLineY; h >= polygonMinY; h -= 1) {
          let points = [];
          if (aet == null) {
            aet = structuredClone(edgeTable.get(Math.round(polygonMinY)));
            let e = aet;
            while (e != null) {
              e.xTek = e.xmin;
              e = e.next;
            }
          } else {
            let e = aet;
            while (e != null) {
              e.xTek += e.slope;
              e = e.next;
            }
            console.log(h);
            if (edgeTable.has(Math.round(h))) {
              console.log("help");
              let newEdges = structuredClone(edgeTable.get(Math.round(h)));
              let edge = newEdges;
              while (edge != null) {
                edge.xTek = edge.xmin;
                // edge.xTek = edge.xTek -= edge.slope;
                edge = edge.next;
              }
              newEdges.next = aet;
              aet = newEdges;
            }
            /*for (let i = h + lineDistance; i >= h; i--) {
              if (edgeTable.has(i)) {
                let newEdges = structuredClone(edgeTable.get(i));
                let edge = newEdges;
                while (edge != null) {
                  edge.xTek = edge.xmax;
                  edge.xTek = edge.xTek -= edge.slope * (i - h);
                  edge = edge.next;
                }
                newEdges.next = aet;
                aet = newEdges;
              }
            }*/
          }
          e = aet;
          let prev = null;
          while (e != null) {
            if (e.ymin > h) {
              if (prev != null) {
                prev.next = e.next;
              } else {
                aet = e.next;
                prev = null;
              }
            } else {
              points.push({ x: e.xTek, y: h });
            }
            prev = e;
            e = e.next;
          }
          points.sort((a, b) => a.x - b.x);
          intersections.push(points);
        }
        console.log(edgeTable);
        return intersections;
        aet = null;
        for (let h = baseLineY; h <= polygonMaxY; h += lineDistance) {
          let points = [];
          if (aet == null) {
            aet = structuredClone(edgeTable.get(polygonMaxY));
          } else {
            let e = aet;
            while (e != null) {
              e.xTek -= e.slope * lineDistance;
              e = e.next;
            }
            for (let i = h - lineDistance; i < h; i++) {
              if (edgeTable.has(i)) {
                let newEdges = structuredClone(edgeTable.get(i));
                let edge = newEdges;
                while (edge != null) {
                  edge.xTek = edge.xTek += edge.slope * (h - i);
                  edge = edge.next;
                }
                newEdges.next = aet;
                aet = newEdges;
              }
            }
          }
          e = aet;
          let prev = null;
          while (e != null) {
            if (e.ymax > h) {
              if (prev != null) {
                prev.next = e.next;
              } else {
                aet = e.next;
                prev = aet;
              }
            } else {
              points.push({ x: e.xTek, y: h });
            }
            prev = e;
            e = e.next;
          }
          points.sort((a, b) => a.x - b.x);
          intersections.push(points);
        }
        return intersections;
      }
      function getAllIntersections(polygon, baseLineY, lineDistance) {
        let minMaxY = getMinMaxY(polygon);
        let polygonMaxY = minMaxY.maxY;
        let polygonMinY = minMaxY.minY;
        let polygonLines = pairwise(polygon);
        let intersections = [];
        for (let h = baseLineY; h >= polygonMinY; h -= lineDistance) {
          intersections.push(findIntersectionsAtY(polygonLines, h));
        }
        intersections = intersections.reverse();
        for (
          let h = baseLineY + lineDistance;
          h <= polygonMaxY;
          h += lineDistance
        ) {
          intersections.push(findIntersectionsAtY(polygonLines, h));
        }
        return intersections;
      }
      function getMinMaxY(polygon) {
        let ys = polygon.map((v) => v.y);
        let maxY = Math.max(...ys);
        let minY = Math.min(...ys);
        return { maxY, minY };
      }
      function isDotInRectangle(upperLeftCorner, lowerRighCorner, dot) {
        return (
          dot.x > upperLeftCorner.x &&
          dot.x < lowerRighCorner.x &&
          dot.y < lowerRighCorner.y &&
          dot.y > upperLeftCorner.y
        );
      }
      function drawPolygon(polygon) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        let midPoint = getMidPoint(polygon);
        let ind1 = 0,
          ind2 = 5;
        let point = { x: polygon[ind1].x, y: polygon[ind1].y };
        let point2 = { x: polygon[ind2].x, y: polygon[ind2].y };
        let deg = -getAngle(point2, point);

        translatePolygon(polygon, -midPoint.x, -midPoint.y);
        rotatePolygon(polygon, deg);

        translatePolygon(polygon, midPoint.x, midPoint.y);
        //ctx.translate(midPoint.x, midPoint.y);
        //ctx.rotate(-radians(deg));
        //ctx.translate(-midPoint.x, -midPoint.y);
        // ctx.translate(0, -deltaY);

        ctx.fillStyle = "#0077CC66";
        ctx.strokeStyle = "#0077CC";
        let path = new Path2D();
        path.moveTo(polygon[0].x, polygon[0].y);
        for (let i = 1; i < polygon.length; i++) {
          path.lineTo(polygon[i].x, polygon[i].y);
        }
        path.lineTo(polygon[0].x, polygon[0].y);

        ctx.fill(path);
        ctx.stroke(path);
        panels.push(path);
        let lines = pairwise(polygon);
        let intersections = getIntersectionsV2(
          polygon,
          polygon[ind1].y,
          panelSize.height
        );
        console.log(intersections);
        for (let i = 0; i < intersections.length; i++) {
          for (let j = 0; j < intersections[i].length - 1; j++) {
            drawDot(intersections[i][j]);
            drawDot(intersections[i][j + 1]);
            drawHelperLine(intersections[i][j], intersections[i][j + 1]);
          }
        }
        ctx.fillStyle = "#FF77CC66";
        ctx.strokeStyle = "#FF77CC";
        canvas.addEventListener("click", (e) => {
          console.log(e.offsetX, e.offsetY);
          panels.forEach((panel, index) => {
            if (ctx.isPointInPath(panel, e.offsetX, e.offsetY)) {
              console.log("kliknut", index);
            }
          });
        });
      }
    </script>
  </body>
</html>
